import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean syntaxErrors = false;

  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
    report_error(
    "Syntax error at line " + (current_token.left+1) + ", column "
    + current_token.right, null
    );
	syntaxErrors = true;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal MAIN, BOOL, CHAR, DICT, INT, RATIONAL, FLOAT, TOP, SEQ, IN, TRUE, FALSE, TDEF, FDEF, VOID, ALIAS, IF, ELIF, ELSE, FORALL, WHILE, READ, PRINT, RETURN, OD, DO, FI, LEN, LESSEQUAL, MOREEQUAL, ISEQUAL, NOTEQUAL, STARTCOMMENT, ENDCOMMENT, LCURLY, RCURLY, LSQUARE, RSQUARE, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV, LESSTHAN, LINECOMMENT, NOT, AND, OR, POWER, MORETHAN, DCOLON, COLON, INTEGER, IDENTIFIER, LET, CHARACTER, KFLOAT, KRAT, COMMA, THEN;
terminal LPAREN, RPAREN;
terminal BADCHAR;

nonterminal top_level, elifs, functions, statement, expr, exprs, sequence, main, func, statements, function_call, arguments, type, funcarguments, funcargument, operator, assignment;

precedence left ISEQUAL, NOTEQUAL, LESSTHAN, LESSEQUAL, MORETHAN, MOREEQUAL, OR, AND, NOT;
precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence left POWER;
precedence left LPAREN, RPAREN;

/* The grammar */
top_level ::= functions main functions;

functions ::= func functions
              |
              ;

main ::= MAIN LCURLY statements RCURLY SEMICOL;

func ::= FDEF type IDENTIFIER LPAREN funcarguments RPAREN LCURLY statements RCURLY SEMICOL
        |
        FDEF type IDENTIFIER LPAREN RPAREN LCURLY statements RCURLY SEMICOL;
		
funcarguments ::= funcargument COMMA funcargument
                |
                funcargument;

funcargument ::= type IDENTIFIER;

type ::= KFLOAT 
        | 
        KRAT 
        | 
        INT 
        | 
        CHAR 
        | 
        DICT /*dict stuff*/ 
        |
        SEQ LESSTHAN type MORETHAN
        |
        IDENTIFIER /*for custom types*/;

statements ::= statements statement 
		|
		statement;
		
statement ::= expr SEMICOL
      |
      assignment SEMICOL
      |
      READ IDENTIFIER SEMICOL
      |
      PRINT expr SEMICOL
      |
      IF LPAREN expr RPAREN THEN statements FI
      |
      IF LPAREN expr RPAREN THEN statements ELSE statements FI
      |
      IF LPAREN expr RPAREN THEN statements elifs ELSE statements FI
      |
      IF LPAREN expr RPAREN THEN statements elifs FI
      |
      WHILE LPAREN expr RPAREN DO statements OD
      |
      FORALL LPAREN IDENTIFIER IN IDENTIFIER RPAREN DO statements OD
      |
      RETURN expr SEMICOL;

elifs ::= ELIF LPAREN expr RPAREN statements 
         |
         ELIF LPAREN expr RPAREN statements elifs;

assignment ::= type IDENTIFIER EQUAL expr;

expr ::= IDENTIFIER
		|
		FLOAT
		|
		INTEGER
    |
    CHARACTER
    |
    RATIONAL
    |
    expr operator expr
    |
    LPAREN expr RPAREN
    |
    function_call
    |
    sequence
    |
    ;

sequence ::= LSQUARE exprs RSQUARE;

exprs ::= expr
        |
        expr COMMA exprs;

function_call ::= IDENTIFIER LPAREN arguments RPAREN
				|
				IDENTIFIER LPAREN RPAREN;

arguments ::= expr COMMA arguments 
			|
			expr;

operator ::= PLUS
            |
            MINUS
            |
            MULT
            |
            DIV
            |
            ISEQUAL
            |
            NOTEQUAL
            |
            LESSEQUAL
            |
            MOREEQUAL
            |
            LESSTHAN
            |
            MORETHAN
            |
            POWER
            |
            NOT
            |
            AND
            |
            OR;