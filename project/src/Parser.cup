import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean syntaxErrors = false;

  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
    report_error(
    "Syntax error at line " + (current_token.left+1) + ", column "
    + current_token.right, null
    );
	syntaxErrors = true;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal MAIN, KBOOL, KCHAR, DICT, KINT, RATIONAL, FLOAT, TOP, SEQ, IN, TRUE, FALSE, TDEF, FDEF, VOID, ALIAS, IF, ELIF, ELSE, FORALL, WHILE, READ, PRINT, RETURN, OD, DO, FI, LEN, LESSEQUAL, MOREEQUAL, ISEQUAL, NOTEQUAL, LCURLY, RCURLY, LSQUARE, RSQUARE, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV, LESSTHAN, NOT, AND, OR, POWER, MORETHAN, DCOLON, COLON, INTEGER, IDENTIFIER, CHARACTER, KFLOAT, KRAT, COMMA, THEN, STRING, LPAREN, RPAREN, DOT;
terminal BADCHAR;

nonterminal top_level, elif, functions, statement, expr, exprs, main, func, statements, function_call, type, operator, assignment, keyvals, typedef, typeids, index, expr_no, numeric, nested;

precedence left OR, AND, NOT;
precedence left ISEQUAL, NOTEQUAL, LESSTHAN, LESSEQUAL, MORETHAN, MOREEQUAL;
precedence left DCOLON;
precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence left POWER;
precedence left LPAREN, RPAREN;

/* The grammar */
top_level ::= functions main functions;

functions ::= func functions
              |
              assignment SEMICOL functions //globals
              |
              typedef functions
              |
              ALIAS type type SEMICOL functions
              |
              ;

typedef ::= TDEF IDENTIFIER LCURLY typeids RCURLY SEMICOL;

typeids ::= type IDENTIFIER
            |
            type IDENTIFIER COMMA typeids;

main ::= MAIN LCURLY statements RCURLY SEMICOL;

func ::= FDEF type IDENTIFIER LPAREN typeids RPAREN LCURLY statements RCURLY SEMICOL
        |
        FDEF VOID IDENTIFIER LPAREN typeids RPAREN LCURLY statements RCURLY SEMICOL
        |
        FDEF type IDENTIFIER LPAREN RPAREN LCURLY statements RCURLY SEMICOL
        |
        FDEF VOID IDENTIFIER LPAREN RPAREN LCURLY statements RCURLY SEMICOL;

type ::= KFLOAT 
        | 
        KRAT 
        |
        KBOOL
        | 
        KINT 
        | 
        KCHAR 
        | 
        DICT LESSTHAN type COMMA type MORETHAN
        | 
        DICT LESSTHAN TOP COMMA type MORETHAN
        | 
        DICT LESSTHAN type COMMA TOP MORETHAN
        |
        DICT LESSTHAN TOP COMMA TOP MORETHAN
        |
        SEQ LESSTHAN type MORETHAN
        |
        SEQ LESSTHAN TOP MORETHAN
        |
        IDENTIFIER /*for custom types*/;

statements ::= statements statement 
		|
		statement;
		
statement ::= expr_no SEMICOL
      |
      assignment SEMICOL
      |
      IDENTIFIER EQUAL expr SEMICOL //reassignment 1
      |
      nested EQUAL expr SEMICOL //reassignment 2
      |
      READ IDENTIFIER SEMICOL
      |
      PRINT expr SEMICOL
      |
      IF LPAREN expr RPAREN THEN statements FI
      |
      IF LPAREN expr RPAREN THEN statements ELSE statements FI
      |
      IF LPAREN expr RPAREN THEN statements elif ELSE statements FI
      |
      IF LPAREN expr RPAREN THEN statements elif FI
      |
      WHILE LPAREN expr RPAREN DO statements OD
      |
      FORALL LPAREN IDENTIFIER IN IDENTIFIER RPAREN DO statements OD
      |
      RETURN expr_no SEMICOL
      |
      ALIAS type type SEMICOL
      |
      typedef;

elif ::= ELIF LPAREN expr RPAREN THEN statements 
         |
         ELIF LPAREN expr RPAREN THEN statements elif;

assignment ::= type IDENTIFIER EQUAL exprs
              |
              type IDENTIFIER;

expr_no ::= expr
            |
            ;

expr ::= IDENTIFIER
		|
		numeric
    |
    CHARACTER
    |
    STRING
    |
    TRUE
    |
    FALSE
    |
    LEN LPAREN IDENTIFIER RPAREN //len()
    |
    expr operator expr
    |
    LPAREN expr RPAREN
    |
    function_call
    |
    LSQUARE exprs RSQUARE //init sequence
    |
    LSQUARE RSQUARE
    |
    IDENTIFIER index //access index or indices in sequence
    |
    IDENTIFIER IN IDENTIFIER
    |
    LCURLY keyvals RCURLY //init dictionary
    |
    nested;

nested ::= IDENTIFIER DOT IDENTIFIER
           |
           nested DOT IDENTIFIER;

numeric ::= INTEGER
            |
            FLOAT
            |
            RATIONAL
            |
            MINUS numeric;

index ::= LSQUARE expr RSQUARE
          |
          LSQUARE expr_no COLON expr_no RSQUARE
          |
          LSQUARE expr RSQUARE index;

keyvals ::= expr COLON expr 
            |
            expr COLON expr COMMA keyvals;

exprs ::= expr
        |
        expr COMMA exprs;

function_call ::= IDENTIFIER LPAREN exprs RPAREN
				|
				IDENTIFIER LPAREN RPAREN;

operator ::= PLUS
            |
            MINUS
            |
            MULT
            |
            DIV
            |
            ISEQUAL
            |
            NOTEQUAL
            |
            LESSEQUAL
            |
            MOREEQUAL
            |
            LESSTHAN
            |
            MORETHAN
            |
            POWER
            |
            NOT
            |
            AND
            |
            OR
            |
            DCOLON;